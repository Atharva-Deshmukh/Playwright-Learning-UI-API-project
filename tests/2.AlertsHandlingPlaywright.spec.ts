import { test, expect } from '@playwright/test';

test('Verify alert', async ({ page }) => {

  /* Handle alert as below */
  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('alert');                 /* Type of dialog */
    expect(await dialog.message()).toBe('I am an alert box!'); /* Message of dialog */
    await dialog.accept();                                     /* Accept the alert */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const alertButton = await page.locator('#alertBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(alertButton).toBeVisible().then(async () => {
      await alertButton.click();
      await page.waitForTimeout(5000); // Hard Wait for 5 seconds to observe the alert
  });

});

test('Verify Confirmation with OK', async ({ page }) => {

  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('confirm');             /* Type of dialog */
    expect(await dialog.message()).toBe('Press a button!');  /* Message of dialog */
    await dialog.accept();   /* Closes confirmation with OK */
    // await dialog.dismiss();   /* Closes confirmation with Cancel */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const confirmButton = await page.locator('#confirmBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(confirmButton).toBeVisible().then(async () => {
      await confirmButton.click();
  });

});

test('Verify Prompt dialogue with OK and some message', async ({ page }) => {

  page.on('dialog', async (dialog) => {
    expect(await dialog.type()).toBe('prompt');             /* Type of dialog */
    expect(await dialog.message()).toBe('Please enter your name:');  /* Message of dialog */
    expect(await dialog.defaultValue()).toBe('Harry Potter'); /* Default value in the prompt */

    await dialog.accept('INPUT MESSAGE');   /* Closing prompt with some input message */
    // await dialog.dismiss();   /* Closes prompt with Cancel */
  });

  const url: string = 'https://testautomationpractice.blogspot.com/';
  const expectedPageTitle: string = 'Automation Testing Practice';
  const promptButton = await page.locator('#promptBtn');

  await page.goto(url);

  await expect(page).toHaveTitle(expectedPageTitle);
  await expect(promptButton).toBeVisible().then(async () => {
      await promptButton.click();
      expect(await page.locator('p#demo')).toHaveText('Hello INPUT MESSAGE! How are you today?');
  });
});

test('Handling Basic authentication popup Way-1', async ({ page }) => {

  // We will add username and pwd directly in URL before domain name
  const url: string = 'https://admin:admin@the-internet.herokuapp.com/basic_auth';
  //                          ----------

  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

test('Handling Basic authentication popup Way-2', async ({ page }) => {

  /* In postman console we can see
    GET https://the-internet.herokuapp.com/basic_auth
    200
    253 ms
    Network
    Request Headers
    Authorization: Basic YWRtaW46YWRtaW4=
                  -----------------------
                  This is the token that is generated by encoding the username and password
                  It is generated by a common JS method btoa()

    User-Agent: PostmanRuntime/7.45.0 */

  const url: string = 'https://the-internet.herokuapp.com/basic_auth';
  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  const username: string = 'admin';
  const password: string = 'admin';
  const authToken: string = 'Basic ' + btoa(`${username}:${password}`);

  await page.setExtraHTTPHeaders({
    'Authorization': authToken
  });

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

test('Configured Basic Authentication Way-3', async ({ page }) => {

  const url: string = 'https://the-internet.herokuapp.com/basic_auth';

  /* use: {

    httpCredentials: {
      username: 'admin',
      password: 'admin',
    }
  }, */

  const authSuccessLocator = await page.locator('h3:has-text("Basic Auth")');

  await page.goto(url);
  await expect(authSuccessLocator).toBeVisible();
});

/* page.addLocatorHandler() 

  In real apps, stuff randomly blocks your test:
    Cookie banners
    “Accept terms” modals
    Newsletter popups
    “What’s new” dialogs

  They can appear:
    only sometimes
    on different pages
    in the middle of an action

   The core idea of page.addLocatorHandler()

    You register a rule: -> “Whenever this locator appears, automatically run this code.”

    Playwright then:
      keeps watching the page
      if the locator matches something visible
      it runs your handler before your test action fails
      Think of it as an automatic popup interceptor.

   What actually happens under the hood

  When your test runs -> await page.click('#buy-button');

  Playwright internally:
    Tries to perform the click
    Notices the click is blocked or interrupted
    Checks registered locator handlers
    Sees “Accept cookies” is visible
    Runs your handler
    Retries the original action
    Your test never even knows the popup existed.

    ORIGINAL ACTION that playwright was trying to do before the modal/overlay appeared is retried



  Now, we need to know noWaitAfter flag
  By default, most actions auto-wait.
  Example -> await page.click('a#login');

  Playwright assumes:

  “This click might trigger navigation, DOM changes, or page load — I’ll wait until things settle.”

  So it waits for:
    navigation (if any)
    network idle / DOM stability
    the action to be “complete”

  noWaitAfter tells Playwright -> “Do the action, but don’t wait for whatever it triggers.”

  It does not:
    skip waiting for the element to be clickable
    skip visibility checks
    skip actionability checks

  It only skips waiting after the action.

  Why this flag exists?
  ---------------------
  Some actions intentionally trigger things Playwright shouldn’t wait for.

  like Opening a new tab / popup

  await page.click('a[target=_blank]', { noWaitAfter: true });

  Without noWaitAfter, Playwright might:
    wait forever
    assume a navigation that never finishes

  
   We also need to specify when to stop waiting for the handler
   -------------------------------------------------------------
   Locator version (preferred nowadays) -> await page.locator('#save').click({ noWaitAfter: true });

  You can also automatically remove the handler after a number of invocations by setting times:
    await page.addLocatorHandler(page.getByLabel('Close'), async locator => {
      await locator.click();
    }, { times: 1 });
*/
test.only('Handling Randomly appearing MODALS', async ({ page }) => {

  const url: string = 'https://commitquality.com/practice-random-popup';
  const accordianLocator = await page.getByText('Accordion 1');
  const modalLocator = await page.locator('.overlay-content p:has-text("Random Popup")');
  const closeModalButtonLocator = await page.locator('.overlay-content button:has-text("Close")');

  /* Setup the handler to close the modal */
  await page.addLocatorHandler(modalLocator, async () => {
    await closeModalButtonLocator.click();
  }, {times: 1});

  await page.goto(url);
  await expect(accordianLocator).toBeVisible();
  await new Promise(resolve => setTimeout(resolve, 6000)); // Wait for the modal to appear
  await accordianLocator.click();
});